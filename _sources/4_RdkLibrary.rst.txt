RDK Library
=============

The Flexiv RDK library allows the robot to be monitored and controlled 
by developers via Ethernet connection. Developers have real-time access to 
the states data from the robot. Control commands can be sent to the robot and get 
executed at a rate of up to 1000 Hz.

API documentation
------------------

To get a complete view of APIs in the RDK library, please refer to the 
`Doxygen generated API documentation <https://flexivrobotics.github.io/flexiv_rdk/>`_.

Library files
-------------

Below is the file structure of the library:

::

    flexiv_rdk
    ├── include          
    │   ├── Mode.hpp
    │   └── Model.hpp
    │   └── Robot.hpp
    │   └── RobotStates.hpp
    ├── lib          
    │   └── libFlexivRdk.a
    ├── example          
    │   └── (various examples)
    ├── test          
    │   └── (various tests)
    └── urdf          
        └── (URDF with accurate kinematics and approximated dynamics)
        └── meshes
            └── (mesh files for visual and collision)

.. csv-table::
   :file: ./file_desc.csv
   :header-rows: 1


Robot modes
--------------

The robot can be put into different modes to take different kind of commands. Most motion APIs require the 
user to put the robot into a corresponding mode before sending actual control commands. Available modes can 
be found in ``Mode.hpp``. Use ``Robot::setMode()`` to put the robot into a certain mode before sending any commands.
The type of each mode is shown below:

.. csv-table::
   :file: ./control_mode.csv
   :header-rows: 1


Idle mode
~~~~~~~~~

The robot holds it’s current position while waiting for user command. The corresponding enum of this mode 
is ``flexiv::MODE_IDLE``.

Real-time modes
~~~~~~~~~~~~~~~~~~~~~~~

When the robot is in real-time modes, user commands will be executed right away without excessive processing 
or filtering to ensure the control loop is at 1kHz.

Joint position mode
^^^^^^^^^^^^^^^^^^^

The robot accepts and executes joint position commands streamed at 1kHz. 
The corresponding enum of this mode is ``flexiv::MODE_JOINT_POSITION``, 
and the command can be sent to the robot using ``flexiv::Robot::streamJointPosition()``.

Joint torque mode
^^^^^^^^^^^^^^^^^

The robot accepts and executes joint torque commands streamed at 1kHz.
The corresponding enum of this mode is ``flexiv::MODE_JOINT_TORQUE``, 
and the command can be sent to the robot using ``flexiv::Robot::streamJointTorque()``.

Cartesian impedance mode
^^^^^^^^^^^^^^^^^^^^^^^^^

The robot accepts Cartesian pose commands streamed at 1kHz, and execute them using a
built-in Cartesian impedance controller. The corresponding enum of this mode is ``flexiv::MODE_CARTESIAN_IMPEDANCE``, 
and the command can be sent to the robot using ``flexiv::Robot::streamTcpPose()``.


Non-real-time modes
~~~~~~~~~~~~~~~~~~~~~~~

When the robot is in non-real-time modes, instead of streaming commands at 1kHz, the user sends only high-level action instructions.

Primitive execution mode
^^^^^^^^^^^^^^^^^^^^^^^^

The robot accepts and executes primitives specified by the user. The corresponding enum of this mode 
is ``flexiv::MODE_PRIMITIVE_EXECUTION``. The primitive command and parameters can be sent using ``flexiv::Robot::executePrimitive()``.

Plan execution mode
^^^^^^^^^^^^^^^^^^^

The robot will execute plans specified by the user. The corresponding enum of this mode is ``flexiv::MODE_PLAN_EXECUTION``. 
A list of available plans can be obtained using ``flexiv::Robot::getPlanNameList()``, and the plan command can be sent using 
``flexiv::Robot::executePlanByIndex()`` or ``flexiv::Robot::executePlanByName()``.

Robot states
-------------

Robot states refer to the measured or estimated information of the robot. The data structure containing 
these information can be found in the header file ``RobotStates.hpp``. Robot states are updated and published 
to the user in real time at 1kHz. However, the user is able to control how often they fetch the data by simply controlling 
the rate at which ``flexiv::Robot::getRobotStates()`` is called.

System status
--------------

System status refers to system-level information of the robot. The data structure containing these information 
is also in the header file ``RobotStates.hpp``. Similar to robot states, system status is updated and published 
to user in real time at 1kHz. However, the user is able to control how often they fetch the data by simply controlling 
the rate at which ``flexiv::Robot::getSystemStatus()`` is called.

Digital I/O control
---------------------

The RDK library also provides the users with the ability to control the digital I/O ports located on the robot's control box. 
16 digital outputs and 16 digital inputs are available, and the user can interact with them via ``flexiv::Robot::writeDigitalOutput()`` 
and ``flexiv::Robot::readDigitalInput()``.
