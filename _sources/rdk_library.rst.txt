RDK Library
=============

All functionalities of RDK are packed into the Flexiv RDK library, which allows the robot to be monitored and 
controlled by a workstation PC running programs compiled from the library. Users will have real-time access to 
the states data from the robot. When the robot is put into a real-time operation mode, low-level control commands 
can be sent to the robot and executed at 1kHz. Non-real-time operation modes are also available for the users to 
send high-level commands.


Library files
-------------

As mentioned in the start page, all RDK library files are hosted on GitHub as ``flexiv_rdk`` 
repository at `<https://github.com/flexivrobotics/flexiv_rdk/>`_. 
Below is a brief file structure of the library::

    flexiv_rdk
    ├── include          
    │   └── (headers with RDK library APIs)
    ├── lib          
    │   └── libFlexivRdk.a (static library for C++ interface)
    │   └── flexivrdk.so (dynamic library for Python interface)
    ├── example          
    │   └── (examples covering most APIs for C++ interface)
    ├── example_py          
    │   └── (examples covering most APIs for Python interface)
    ├── test          
    │   └── (functionality tests)
    ├── spec          
    │   └── (URDF with accurate robot kinematics but approximated dynamics)
    │   └── meshes
    │       └── (mesh files for visual and collision)
    └── thirdparty          
        └── Eigen (header-only Eigen library required by RDK)

API documentation
------------------

The detailed documentation on all APIs of the RDK library can be found at 
`<https://flexivrobotics.github.io/flexiv_rdk/>`_.


Programming language interfaces
--------------------------------

**C++** and **Python** are currently supported by RDK. The C++ interface has access to all APIs, including real-time (RT) 
and non-real-time (NRT) ones, while the Python interface can only access some non-real-time (NRT) APIs as listed below:

+-----------------------+-------------------------------------------------------------+
| API                   | Access from Python interface                                |
+=======================+=============================================================+
| flexiv::Robot         | Partial access, as indicated by ``@version`` of each method |
+-----------------------+-------------------------------------------------------------+
| flexiv::RobotStates   | Full access, except for any operator overloading            |
+-----------------------+-------------------------------------------------------------+
| flexiv::Mode          | Full access                                                 |
+-----------------------+-------------------------------------------------------------+
| flexiv::Log           | No access                                                   |
+-----------------------+-------------------------------------------------------------+
| flexiv::Model         | No access                                                   |
+-----------------------+-------------------------------------------------------------+
| flexiv::Visualization | No access                                                   |
+-----------------------+-------------------------------------------------------------+


Robot modes
--------------

The robot can be put into different modes to take different kind of commands. Most motion APIs require the 
user to put the robot into a corresponding mode before sending actual control commands. Available modes can 
be found in ``Mode.hpp``. Use ``Robot::setMode()`` to put the robot into a certain mode before sending any commands.
The type of each mode is shown below:

+------------------------------+------+
| Mode                         | Type |
+==============================+======+
| Idle mode                    | Idle |
+------------------------------+------+
| Joint torque mode            | RT   |
+------------------------------+------+
| Joint position mode          | RT   |
+------------------------------+------+
| Cartesian impedance mode     | RT   |
+------------------------------+------+
| Joint position NRT mode      | NRT  |
+------------------------------+------+
| Cartesian impedance NRT mode | NRT  |
+------------------------------+------+
| Plan execution mode          | NRT  |
+------------------------------+------+
| Primitive execution mode     | NRT  |
+------------------------------+------+

| RT: real-time, NRT: non-real-time


Idle mode
~~~~~~~~~

The robot holds it’s current position while waiting for user command. The corresponding enum of this mode 
is ``flexiv::MODE_IDLE``.

Real-time modes
~~~~~~~~~~~~~~~~~~~~~~~

When the robot is in real-time modes, the user can send real-time motion commands at 1kHz, which will be executed 
right away without excessive processing or filtering to ensure the control loop is running at 1kHz.

Joint torque mode
^^^^^^^^^^^^^^^^^

The robot accepts joint torque commands streamed at 1kHz, and execute them using a built-in joint torque controller. 
Gravity and friction are compensated. The corresponding enum of this mode is ``flexiv::MODE_JOINT_TORQUE``, 
and the command can be sent to the robot using ``flexiv::Robot::streamJointTorque()``.

Joint position mode
^^^^^^^^^^^^^^^^^^^

The robot accepts joint position commands streamed at 1kHz, and execute them using a built-in joint position controller. 
Gravity, friction, and dynamics are compensated. The corresponding enum of this mode is ``flexiv::MODE_JOINT_POSITION``, 
and the command can be sent to the robot using ``flexiv::Robot::streamJointPosition()``.

Cartesian impedance mode
^^^^^^^^^^^^^^^^^^^^^^^^^

The robot accepts Cartesian pose commands streamed at 1kHz, and execute them using a built-in Cartesian impedance controller. 
Gravity, friction, and dynamics are compensated. The corresponding enum of this mode is ``flexiv::MODE_CARTESIAN_IMPEDANCE``, 
and the command can be sent to the robot using ``flexiv::Robot::streamTcpPose()``.


Non-real-time modes
~~~~~~~~~~~~~~~~~~~~~~~

When the robot is in non-real-time modes, the user can send non-real-time motion commands at less than 1kHz or 
high-level action instructions like plans and primitives.

Joint position NRT mode
^^^^^^^^^^^^^^^^^^^^^^^

Non-real-time version of the joint position mode. The robot accepts joint position commands at less than 1kHz, 
and smoothen the target points with a built-in motion generator, then execute them using a built-in joint position 
controller. Gravity, friction, and dynamics are compensated. The corresponding enum of this mode is ``flexiv::MODE_JOINT_POSITION_NRT``, 
and the command can be sent to the robot using ``flexiv::Robot::sendJointPosition()``.

Cartesian impedance NRT mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Non-real-time version of the Cartesian impedance mode. The robot accepts Cartesian pose commands at less than 1kHz, 
and smoothen the target points with a built-in motion generator, then execute them using a built-in Cartesian impedance 
controller. Gravity, friction, and dynamics are compensated. The corresponding enum of this mode is ``flexiv::MODE_CARTESIAN_IMPEDANCE_NRT``, 
and the command can be sent to the robot using ``flexiv::Robot::sendTcpPose()``.

Primitive execution mode
^^^^^^^^^^^^^^^^^^^^^^^^

The robot accepts and executes primitives specified by the user. The corresponding enum of this mode 
is ``flexiv::MODE_PRIMITIVE_EXECUTION``. The primitive command and parameters can be sent using ``flexiv::Robot::executePrimitive()``.

Plan execution mode
^^^^^^^^^^^^^^^^^^^

The robot will execute plans specified by the user. The corresponding enum of this mode is ``flexiv::MODE_PLAN_EXECUTION``. 
A list of available plans can be obtained using ``flexiv::Robot::getPlanNameList()``, and the plan command can be sent using 
``flexiv::Robot::executePlanByIndex()`` or ``flexiv::Robot::executePlanByName()``.

Robot states
-------------

Robot states refer to the measured or estimated information of the robot. The data structure containing 
these information can be found in the header file ``RobotStates.hpp``. Robot states are updated and published 
to the user in real time at 1kHz. However, the user is able to control how often they fetch the data by simply controlling 
the rate at which ``flexiv::Robot::getRobotStates()`` is called.

System status
--------------

System status refers to system-level information of the robot. The data structure containing these information 
is also in the header file ``RobotStates.hpp``. Similar to robot states, system status is updated and published 
to user in real time at 1kHz. However, the user is able to control how often they fetch the data by simply controlling 
the rate at which ``flexiv::Robot::getSystemStatus()`` is called.

Digital I/O control
---------------------

The RDK library also provides the users with the ability to control the digital I/O ports located on the robot's control box. 
16 digital outputs and 16 digital inputs are available, and the user can interact with them via ``flexiv::Robot::writeDigitalOutput()`` 
and ``flexiv::Robot::readDigitalInput()``.


Integrated visualization
-------------------------

RDK has integrated visualization (only available for C++ interface) based on Meshcat. To use this feature:

1. Install Meshcat server using ``pip``::

        pip install meshcat

2. Start the Meshcat server in Terminal::

        meshcat-server

3. It will provide several URLs, open ``web_url`` with a web browser. An empty scene will open up.

4. Use APIs in ``flexiv::Visualization`` to communicate with the Meshcat server, the empty scene will be populated with robot(s) and user-defined objects if any. Refer to ``example/visualization.cpp``.

**Note:** only STL mesh files are supported, which are provided in ``spec/meshes``.