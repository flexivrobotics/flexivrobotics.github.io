Getting Started
====================

.. (TODO) add instruction to configure license
.. (TODO) add instruction to configure external mode on UI

This chapter covers how to establish connection between the robot and the user's workstation PC, 
and run some examples to verify system functionalities. 

Establish connection
--------------------

The following steps show how to physically connect user's workstation PC to the robot:

1. Make sure the system is powered **OFF** and the robot arm is mounted on a stable base. The robot must be securely mounted 
onto a steady base and cannot topple over even when the robot is moving at high speeds with sudden stops.

2. Using an Ethernet cable, connect the Ethernet port on the workstation PC to the Ethernet port on the control box that is marked as LAN. 
Ensure that connectors are firmly attached.

   .. figure:: /_static/ioFullPanel.png
      :width: 75.0%
      :align: center
      :figclass: align-center   

   .. figure:: /_static/ioFullPanelDetails.png
      :width: 75.0%
      :align: center
      :figclass: align-center   
      
   .. important::
      The connection between the robot and the workstation PC should be a direct connection. Going through a 
      router or an ethernet switch can result in reduced control performance due to extra network latency.

3. With the system powered **OFF**, push the **mode selection switch** on the motion bar to upper position (i.e. **auto mode**).

   .. note::
      Refer to the user manual for more details about **auto mode** and **manual mode**. Here we'll need 
      to use auto mode for RDK.

   .. figure:: /_static/MotionBar_Image.png
      :width: 70.0%
      :align: center
      :figclass: align-center

4. Check that the **emergency stop** (E-stop) on the motion bar is pressed down.

5. Power **ON** the system using the power switch located on the control box, then wait until booting is complete. 
   The LED rings on the robot will turn solid **blue** when the robot is ready. This process may take up to 60 seconds.

   .. caution::
      **Blinking** LED rings on the robot indicate a fault occurred. Please refer to the :doc:`troubleshooting` chapter for more details.

6. The default IP address of the robot is ``192.168.2.100``. By this time the connection should already have been established, 
   so check the connection by pinging the robot from the workstation PC::

      ping 192.168.2.100

   The *time* value from the ping command denotes the round trip time and this value should be well below ``1 ms``

   .. note::
      The workstation PC must be in the same subnet (i.e. with IP address ``192.168.2.x``) with the robot in order to connect. 
      However, the user does NOT need to configure the workstation PC's IP address manually, because the robot has its own DHCP 
      server built in. So when the robot finishes booting with the workstation PC is connected, the 
      DHCP server will automatically assign an IP address in the same subnet to the workstation PC.


Additional compiler setup
--------------------------

.. note::
   Skip this step if you are using Ubuntu 20.04, the additional compiler setup is only needed by Ubuntu 18.04.

The Flexiv RDK static library ``libFlexivRdk.a`` is generated by the compiler on a Ubuntu 20.04 machine, which uses newer C++ standard 
than that of Ubuntu 18.04. Thus, for users with Ubuntu 18.04, they need to update the C++ standard headers installed in the workstation PC 
to be able to successfully link to the static library. Use the below Terminal commands to update::

      sudo add-apt-repository ppa:ubuntu-toolchain-r/test
      sudo apt update
      sudo apt install libstdc++6

To make sure the update is successful, check the version of ``libstdc++6`` using::

      sudo apt install libstdc++6

Look for the message ``libstdc++6 is already the newest version``, followed by the actual version number, which should be greater than 10.0.


Obtain RDK library files
-------------------------

The Flexiv RDK library consists of headers, static library, examples, URDF, mesh files, etc. These are all hosted in a public GitHub repository at 
`<https://github.com/flexivrobotics/flexiv_rdk/>`_.

You can Git clone this repository or directly download it as a zip file.


Build and run examples
-----------------------

Now that the connection is established, we'll need to enable the robot and verify the whole setup by running the ``display_robot_states`` 
example, which will enable the robot then continuously get and print the current states of the robot while the robot holds itself at the current pose.

1. Assuming you've cloned or downloaded the ``flexiv_rdk`` repository via the link above.

2. Configure CMake and build all example programs::

      cd flexiv_rdk
      mkdir build && cd build
      cmake ..
      make -j4

3. Check the IP address of the workstation PC itself::
      
      sudo apt install net-tools
      ifconfig

   You should see that one of the network interface has been assigned by the robot an IP address within the same subnet as the robot, for example, ``192.168.2.200``.

4. Assuming the robot has already finished booting and the connection with the user's workstation PC is established according to instructions 
   mentioned above, now release (**pull up**) the emergency stop (E-stop) button on the motion bar. The robot will have no action because 
   an enabling API needs to be called to actually enable the robot.

5. Run the compiled example program ``display_robot_states``, which will first call the aforementioned API to enable the robot, then hold the robot while printing out 
   all robot states. Make sure the E-stop is already pulled up:: 

      cd flexiv_rdk/build/example
      sudo ./display_robot_states <robot_ip> <local_ip>
   
   The ``<local_ip>`` is what you get in step 3, for example::

      sudo ./display_robot_states 192.168.2.100 192.168.2.200

6. The robot will be enabled and release the joint brakes, which will make some audible crispy sound. After a few seconds when the enabling process is done and the robot 
   becomes operational, the 1kHz periodic user task loop will start to run, which in this example mainly prints the joint and Cartesian states of the robot. 
   An excerpt of the output is as follows:

   .. code-block:: c

      {
      "q": [-0.02276,-0.0937682,0.0155674,1.62589,-0.0225268,0.208001,0.305311],
      "theta": [-0.0230455,-0.0920024,0.0158942,1.62436,-0.022891,0.208576,0.307476],
      "dq": [0.148054,0.0437919,0.122067,0.0455735,0.000637466,-0.00113799,0.241857],
      "dtheta": [0.139027,0.0438319,0.121441,0.0512989,-0.000282414,-0.00172493,0.253589],
      "tau": [0.616091,31.0906,0.935915,-23.633,-2.58817,2.43764,0.359142],
      "tau_des": [1.56515,1.33795,0.700978,1.1427,0.2864,-0.113417,0.56946],
      "tau_dot": [-44.9559,-8.10623,8.79854,1.38283,3.13401,14.9822,7.0242],
      "tau_ext": [-0.180099,-0.775732,-0.0763522,-0.69938,-0.44841,0.166297,-0.441835],
      "tcp_pose": [0.55174,-0.114317,0.593904,0.0226307,0.150829,0.988264,-0.00854974],
      "tcp_pose_d": [0.548872,-0.104836,0.593404,0.0257007,0.152765,0.987845,-0.01286],
      "tcp_velocity": [0.00320276,0.141547,-0.00176686,0.0203958,0.00281812,0.00697462],
      "camera_pose": [0.623739,-0.136403,0.635011,0.00995671,-0.592156,0.805461,-0.0220479],
      "flange_pose": [0.55174,-0.114317,0.593904,0.0226307,0.150829,0.988264,-0.00854974],
      "end_link_pose": [0.548621,-0.112561,0.667818,0.00854974,0.988264,-0.150829,0.0226307],
      "F_ext_tcp_frame": [-0.921438,-0.445242,-0.515255,0.139577,0.0974587,-0.323618],
      "F_ext_base_frame": [0.723944,-0.687035,0.562729,-0.117632,0.142245,0.315654],
      }


7. Use ``CTRL+C`` to close the example program. 

   .. note::
      When the RDK user program is terminated or the connection is lost, the robot will automatically decelerate to a halt and hold its position. 
      The robot server supports on-the-fly reconnection, so you can terminate a user program and start a new one without doing anything to the robot side.

The next chapter will provide more details on the RDK library, and you can also check out the other 
examples to get familiar with RDK APIs and how to use them.
